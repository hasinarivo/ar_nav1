<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AR Restaurant Navigator</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        /* [Vos styles CSS existants restent inchangés] */
    </style>
</head>
<body>
    <!-- [Votre HTML existant reste inchangé jusqu'au script] -->

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.module.js';
  import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.132.2/examples/jsm/webxr/ARButton.js';
  import { XRControllerModelFactory } from 'https://cdn.jsdelivr.net/npm/three@0.132.2/examples/jsm/webxr/XRControllerModelFactory.js';
        // [Vos variables et fonctions existantes restent inchangées jusqu'à create3DArrow()]

        // Création de flèches directionnelles stylisées
        function create3DArrow() {
            if (arrow) scene.remove(arrow);
            
            // Matériau bleu métallique avec transparence
            const material = new THREE.MeshPhongMaterial({
                color: 0x4285F4,
                specular: 0x111111,
                shininess: 50,
                transparent: true,
                opacity: 0.9
            });
            
            // Création d'une double flèche directionnelle
            arrow = new THREE.Group();
            
            // Flèche droite (pour tourner à droite)
            const rightArrow = createDirectionIndicator('right');
            rightArrow.position.set(0.5, 0, 0);
            arrow.add(rightArrow);
            
            // Flèche gauche (pour tourner à gauche)
            const leftArrow = createDirectionIndicator('left');
            leftArrow.position.set(-0.5, 0, 0);
            arrow.add(leftArrow);
            
            // Cercle de base
            const circleGeometry = new THREE.RingGeometry(0.3, 0.4, 32);
            const circleMaterial = new THREE.MeshBasicMaterial({
                color: 0x4285F4,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.3
            });
            const circle = new THREE.Mesh(circleGeometry, circleMaterial);
            circle.rotation.x = Math.PI / 2;
            circle.position.y = -0.1;
            arrow.add(circle);
            
            arrow.position.set(0, 0, -2);
            scene.add(arrow);
            
            // Cache les deux flèches initialement
            hideDirectionIndicators();
        }
        
        function createDirectionIndicator(direction) {
            const group = new THREE.Group();
            
            // Tige de la flèche
            const stemGeometry = new THREE.BoxGeometry(0.4, 0.05, 0.1);
            const stem = new THREE.Mesh(stemGeometry, material);
            group.add(stem);
            
            // Pointe de la flèche
            const headGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.1);
            const head = new THREE.Mesh(headGeometry, material);
            
            if (direction === 'right') {
                head.position.set(0.3, 0, 0);
                head.rotation.z = Math.PI / 4;
            } else {
                head.position.set(-0.3, 0, 0);
                head.rotation.z = -Math.PI / 4;
            }
            
            group.add(head);
            group.userData.direction = direction;
            return group;
        }
        
        function hideDirectionIndicators() {
            arrow.children.forEach(child => {
                if (child.userData.direction) {
                    child.visible = false;
                }
            });
        }
        
        function showDirectionIndicator(direction) {
            hideDirectionIndicators();
            arrow.children.forEach(child => {
                if (child.userData.direction === direction) {
                    child.visible = true;
                    
                    // Animation de pulsation
                    const scale = 1 + Math.sin(Date.now() * 0.01) * 0.2;
                    child.scale.set(scale, scale, scale);
                }
            });
        }

        // Mise à jour de la flèche AR
        function updateARPointer() {
            if (!selectedRestaurant || userHeading === null || !arrow) return;
            
            const bearing = calculateBearing(userPosition, selectedRestaurant.position);
            let relativeAngle = (360 - userHeading + bearing) % 360;
            
            // Ajustement pour avoir un angle entre -180 et 180
            if (relativeAngle > 180) relativeAngle -= 360;
            
            document.getElementById('ar-direction').textContent = Math.abs(relativeAngle).toFixed(0) + '° ' + 
                (relativeAngle > 0 ? 'droite' : 'gauche');
            
            // Rotation de l'ensemble des flèches
            arrow.rotation.y = THREE.MathUtils.degToRad(relativeAngle);
            
            // Affiche la flèche appropriée
            if (Math.abs(relativeAngle) > 15) { // Seuil de 15° pour afficher les flèches
                showDirectionIndicator(relativeAngle > 0 ? 'right' : 'left');
            } else {
                // Tout droit - cache les flèches
                hideDirectionIndicators();
            }
        }

        // [Le reste de votre code reste inchangé]
    </script>
</body>
</html>
